<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NetLogo setup with multiple agents and graphs</title>
  <style>
    :root {
      --bg: #f7f4ef;
      --paper: #fffdf9;
      --ink: #1f2937;
      --muted: #5b6473;
      --accent: #0f766e;
      --accent2: #b45309;
      --line: #e7dfd2;
      --code-bg: #0b1220;
      --code-ink: #e5e7eb;
      --code-muted: rgba(229, 231, 235, 0.55);
      --code-hl: rgba(15, 118, 110, 0.25);
      --code-skip: rgba(180, 83, 9, 0.22);
      --good: #0f766e;
      --warn: #b45309;
      --bad: #b91c1c;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 600px at 80% -10%, #d5f5ef 0%, transparent 60%),
        radial-gradient(900px 500px at -10% 10%, #fde7f2 0%, transparent 60%),
        var(--bg);
      line-height: 1.65;
    }
    .wrap {
      max-width: 1240px;
      margin: 26px auto;
      padding: 0 18px 34px;
    }
    .card {
      background: var(--paper);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 20px 20px 22px;
      box-shadow: 0 10px 28px rgba(15, 23, 42, 0.07);
    }
    header {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      justify-content: space-between;
      flex-wrap: wrap;
      padding: 4px 2px 14px;
      border-bottom: 1px solid rgba(231, 223, 210, 0.9);
      margin-bottom: 14px;
    }
    h1 {
      font-size: 22px;
      margin: 0;
      line-height: 1.25;
      color: #0b3b38;
    }
    .sub {
      margin-top: 6px;
      color: var(--muted);
      font-size: 14px;
      max-width: 62ch;
    }
    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .pill {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: #ffffff;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05);
      font-size: 14px;
      color: #0f172a;
    }
    label {
      font-size: 13px;
      color: #0f172a;
      opacity: 0.9;
      white-space: nowrap;
    }
    select {
      font-family: inherit;
      font-size: 14px;
      border-radius: 10px;
      border: 1px solid rgba(231, 223, 210, 0.95);
      padding: 7px 10px;
      background: #fff;
      color: #0f172a;
      cursor: pointer;
    }
    .btn {
      appearance: none;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: #ffffff;
      color: #0f172a;
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05);
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
      user-select: none;
    }
    .btn:active { transform: translateY(1px); box-shadow: 0 3px 10px rgba(15, 23, 42, 0.08); }
    .btn[disabled] { opacity: 0.45; cursor: not-allowed; }
    .btn.primary {
      border-color: rgba(15, 118, 110, 0.35);
      background: linear-gradient(180deg, rgba(15, 118, 110, 0.10), rgba(15, 118, 110, 0.06));
    }
    .grid {
      display: grid;
      grid-template-columns: 1.05fr 1fr;
      gap: 14px;
      /* Don't stretch the code panel to the full height of the demo panel. */
      align-items: start;
    }
    @media (max-width: 1020px) {
      .grid { grid-template-columns: 1fr; }
    }
    @media (min-width: 1021px) {
      /* Keep the demo visible while you scroll the code. */
      .demo {
        position: sticky;
        top: 16px;
        max-height: calc(100vh - 32px);
        overflow: auto;
        align-self: start;
      }
      .code {
        max-height: calc(100vh - 32px);
      }
    }

    /* Left: Code viewer */
    .code {
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: var(--code-bg);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
      min-height: 560px;
    }
    .code-head {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: var(--code-ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
    }
    .code-head .hint { color: var(--code-muted); font-size: 12px; }
    .code-body {
      padding: 10px 0 12px;
      overflow: auto;
      flex: 1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: var(--code-ink);
    }
    .line {
      display: grid;
      grid-template-columns: 44px 1fr;
      gap: 10px;
      padding: 0 12px;
      cursor: pointer;
      user-select: none;
    }
    .line:hover { background: rgba(255,255,255,0.04); }
    .ln {
      text-align: right;
      color: rgba(229,231,235,0.40);
      padding: 6px 0;
      font-variant-numeric: tabular-nums;
    }
    .src {
      white-space: pre;
      padding: 6px 0;
    }
    .line.current { background: var(--code-hl); }
    .line.skipped.current { background: rgba(180, 83, 9, 0.28); }
    .line.skipped .src { color: rgba(229,231,235,0.62); }
    .line.skipped .ln { color: rgba(229,231,235,0.33); }
    .line.executed::before,
    .line.skipped::before {
      content: "";
      width: 4px;
      border-radius: 4px;
      margin-left: -10px;
      margin-right: 6px;
      align-self: stretch;
      background: transparent;
    }
    .line.executed::before { background: rgba(15, 118, 110, 0.65); }
    .line.skipped::before { background: rgba(180, 83, 9, 0.70); }

    /* Right: Demo */
    .demo {
      border-radius: 14px;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: #ffffff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 560px;
    }
    .demo-top {
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(231, 223, 210, 0.9);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .step-title {
      font-size: 14px;
      color: #0f172a;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 13px;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: #fff;
      color: #0f172a;
      font-variant-numeric: tabular-nums;
    }
    .badge strong { font-weight: 700; }
    .badge .ok { color: var(--good); }
    .badge .skip { color: var(--warn); }

    .world {
      padding: 12px 12px 8px;
      background:
        radial-gradient(650px 260px at 60% -20%, rgba(15,118,110,0.10), transparent 55%),
        radial-gradient(600px 250px at 10% 15%, rgba(180,83,9,0.12), transparent 55%),
        #fff;
    }
    .world-frame {
      border-radius: 12px;
      border: 1px solid rgba(231, 223, 210, 0.95);
      background: #fbfaf7;
      overflow: hidden;
    }
    svg#worldSvg {
      display: block;
      width: 100%;
      height: 320px;
    }
    .axis {
      stroke: rgba(15,23,42,0.12);
      stroke-width: 0.05;
      vector-effect: non-scaling-stroke;
    }
    .gridline {
      stroke: rgba(15,23,42,0.06);
      stroke-width: 0.04;
      vector-effect: non-scaling-stroke;
    }
    .edge {
      stroke: rgba(15,23,42,0.62);
      stroke-width: 0.22;
      stroke-linecap: round;
      opacity: 0.95;
      transition: opacity 220ms ease, stroke 220ms ease, stroke-width 220ms ease;
    }
    .edge.new {
      stroke: rgba(15,118,110,0.95);
      stroke-width: 0.30;
      opacity: 1;
    }
    .edge.active {
      stroke: rgba(180,83,9,0.95);
      stroke-width: 0.34;
      opacity: 1;
    }
    .turtle {
      transition: transform 320ms cubic-bezier(0.22, 1, 0.36, 1);
    }
    .turtle circle {
      r: 0.90;
      fill: rgba(15,118,110,0.18);
      stroke: rgba(15,118,110,0.85);
      stroke-width: 0.18;
      transition: fill 220ms ease, stroke 220ms ease, stroke-width 220ms ease;
    }
    .turtle text {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.15px;
      fill: rgba(15,23,42,0.88);
      dominant-baseline: middle;
      text-anchor: middle;
      pointer-events: none;
    }
    .turtle text.alias {
      font-size: 0.90px;
      fill: rgba(180,83,9,0.95);
      letter-spacing: 0.02em;
    }
    .turtle.active circle {
      fill: rgba(180,83,9,0.18);
      stroke: rgba(180,83,9,0.92);
      stroke-width: 0.22;
    }
    .turtle.created circle {
      fill: rgba(15,118,110,0.30);
      stroke-width: 0.22;
    }
    .turtle.center circle {
      fill: rgba(15,23,42,0.10);
      stroke: rgba(15,23,42,0.50);
    }

    .panes {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      padding: 10px 12px 14px;
    }
    .panel {
      border: 1px solid rgba(231, 223, 210, 0.95);
      border-radius: 12px;
      background: #fff;
      padding: 12px 12px 10px;
    }
    .panel h3 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #0b3b38;
    }
    .panel p {
      margin: 6px 0;
      font-size: 14px;
      color: #0f172a;
    }
    .panel .muted { color: var(--muted); font-size: 13px; }
    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
    }
    .kv .k { color: rgba(15,23,42,0.70); }
    .kv .v { color: rgba(15,23,42,0.92); }
    .pill-note {
      display: inline-flex;
      gap: 8px;
      align-items: flex-start;
      padding: 10px 12px;
      border-left: 4px solid rgba(15,118,110,0.75);
      background: rgba(15,118,110,0.06);
      border-radius: 10px;
      font-size: 13px;
      color: #0f172a;
    }
    .pill-note.warn {
      border-left-color: rgba(180,83,9,0.85);
      background: rgba(180,83,9,0.08);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    th, td {
      border-top: 1px solid rgba(231, 223, 210, 0.95);
      padding: 8px 8px;
      text-align: left;
      vertical-align: top;
      font-variant-numeric: tabular-nums;
    }
    th { color: rgba(15,23,42,0.70); font-weight: 700; }
    tr.active td { background: rgba(180,83,9,0.06); }
    tr.created td { background: rgba(15,118,110,0.06); }
    code.inline {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 90%;
      background: rgba(15,23,42,0.05);
      border: 1px solid rgba(231, 223, 210, 0.95);
      padding: 1px 6px;
      border-radius: 7px;
      white-space: nowrap;
    }

    .see-also {
      margin-top: 14px;
    }
    .see-also a {
      color: var(--accent);
      text-decoration: none;
      border-bottom: 1px solid rgba(15, 118, 110, 0.35);
    }
    .see-also a:hover {
      border-bottom-color: rgba(15, 118, 110, 0.75);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div>
          <h1>NetLogo setup with multiple agents and graphs</h1>
          <div class="sub">
            Controls: click <span class="pill"><strong>Next</strong></span> or press <code class="inline">→</code> to step through line by line. The right panel highlights which agents/links/layout elements change on the current line. (This page uses N=6.)
          </div>
        </div>
        <div class="controls">
          <div class="pill">
            <label for="gSelect">Graph G</label>
            <select id="gSelect">
              <option value="complete">complete</option>
              <option value="cycle">cycle</option>
              <option value="wheel">wheel</option>
            </select>
          </div>
          <button class="btn" id="btnPrev" type="button">Prev (←)</button>
          <button class="btn primary" id="btnNext" type="button">Next (→)</button>
          <button class="btn" id="btnReset" type="button">Reset</button>
        </div>
      </header>

      <div class="grid">
        <section class="code" aria-label="Code">
          <div class="code-head">
            <div><strong>setup</strong> source (click any line to jump)</div>
            <div class="hint">Green bar: executed | Orange bar: skipped (condition false)</div>
          </div>
          <div class="code-body" id="codeBody"></div>
        </section>

        <section class="demo" aria-label="Demo">
          <div class="demo-top">
            <div class="step-title" id="stepTitle"></div>
            <div class="badge" id="stepBadge"></div>
          </div>

          <div class="world">
            <div class="world-frame">
              <svg id="worldSvg" viewBox="-10 -10 20 20" role="img" aria-label="Agent demo">
                <g id="gridLayer"></g>
                <g id="edgeLayer"></g>
                <g id="turtleLayer"></g>
              </svg>
            </div>
          </div>

          <div class="panes">
            <div class="panel">
              <h3>What This Line Does</h3>
              <div id="explain"></div>
            </div>
          </div>
        </section>
      </div>

      <section class="panel see-also" aria-label="See also">
        <h3>See also / 另见</h3>
        <p>
          <a href="success_simulate_minimal.nlogox"><code class="inline">success_simulate_minimal.nlogox</code></a>:
          展示如何构建三种不同 graph 的最小实现（<code class="inline">complete</code> / <code class="inline">cycle</code> / <code class="inline">wheel</code>）。
        </p>
        <p>
          <a href="zollman_simulate.nlogox"><code class="inline">zollman_simulate.nlogox</code></a>:
          完整复现 Zollman paper 的仿真代码。
        </p>
      </section>
    </div>
  </div>

  <script>
    // Teaching goal: line-by-line, deterministic demo with N=6 (so wheel != complete).
    const PARAMS = { N: 6, G: 'complete' };

    const CODE_LINES = [
      'to setup',
      '  clear-all',
      '  create-turtles N',
      '  let nAgents count turtles',
      '  if G = "complete" [ ask turtles [ create-links-with other turtles ] ]',
      '  if G = "cycle" [ ask turtles [ create-link-with turtle ((who + 1) mod nAgents) ] ]',
      '  if G = "wheel" [',
      '    let c turtle 0',
      '    ask turtles with [who != 0] [',
      '      create-link-with c',
      '      create-link-with turtle (ifelse-value (who = nAgents - 1) [ 1 ] [ who + 1 ])',
      '    ]',
      '  ]',
      '  ifelse G = "wheel"',
      '    [ layout-circle sort turtles with [who != 0] 8 ask turtle 0 [ setxy 0 0 ] ]',
      '    [ layout-circle sort turtles 8 ]',
      '  reset-ticks',
      'end',
    ];

    function edgeKey(a, b) {
      const x = Math.min(a, b);
      const y = Math.max(a, b);
      return `${x}-${y}`;
    }

    function uniqSorted(arr) {
      return Array.from(new Set(arr)).sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
    }

    function uniqPreserveOrder(arr) {
      const seen = new Set();
      const out = [];
      for (const x of arr) {
        if (seen.has(x)) continue;
        seen.add(x);
        out.push(x);
      }
      return out;
    }

    function clippedSegment(a, b, padA, padB) {
      // Shorten a center-to-center segment so it doesn't intrude into the node circles.
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len = Math.hypot(dx, dy) || 1;
      const ux = dx / len;
      const uy = dy / len;
      const trimA = Math.min(padA, len / 2);
      const trimB = Math.min(padB, len / 2);
      return {
        x1: a.x + ux * trimA,
        y1: a.y + uy * trimA,
        x2: b.x - ux * trimB,
        y2: b.y - uy * trimB,
      };
    }

    function initialPosForWho(who) {
      // Deterministic "spawn" positions (just for teaching visuals).
      const pos = [
        { x: -3.6, y: -2.0 },
        { x:  3.4, y: -2.1 },
        { x: -4.2, y:  1.8 },
        { x:  0.0, y:  3.6 },
        { x:  4.3, y:  1.9 },
        { x:  0.1, y: -3.8 },
      ];
      return pos[who] || { x: 0, y: 0 };
    }

    function layoutCircle(ids, radius) {
      const n = ids.length;
      const out = new Map();
      if (n === 0) return out;
      const start = -Math.PI / 2; // start at "top"
      for (let i = 0; i < n; i++) {
        const ang = start + (2 * Math.PI * i) / n;
        out.set(ids[i], { x: radius * Math.cos(ang), y: radius * Math.sin(ang) });
      }
      return out;
    }

    function makeState(params) {
      return {
        turtles: [],
        links: [],
        vars: { N: params.N, G: params.G, nAgents: undefined, c: undefined },
        context: { wheelIf: null, askSet: null, ifelseCond: null },
        ticks: null,
      };
    }

    function cloneState(s) {
      return JSON.parse(JSON.stringify(s));
    }

    function addLink(state, a, b) {
      if (a === b) return;
      const k = edgeKey(a, b);
      if (!state.links.includes(k)) state.links.push(k);
    }

    function getTurtle(state, who) {
      return state.turtles.find(t => t.who === who) || null;
    }

    function turtleIds(state) {
      return state.turtles.map(t => t.who).sort((a, b) => a - b);
    }

    function applyLine(i, state, params) {
      // Keep UI inputs visible as "vars" even across clear-all.
      state.vars.N = params.N;
      state.vars.G = params.G;

      // Metadata about this line (for highlighting).
      const meta = {
        executed: true,
        activeTurtles: [],
        newEdges: [],
        newEdgeDisplay: [],
        noteKind: null, // 'warn' etc
      };

      const G = params.G;
      const N = params.N;

      switch (i) {
        case 0: { // to setup
          meta.executed = true;
          break;
        }
        case 1: { // clear-all
          // In NetLogo, clear-all clears turtles/links/etc and resets ticks.
          const keepInputs = { N: state.vars.N, G: state.vars.G };
          state.turtles = [];
          state.links = [];
          state.vars = { ...keepInputs, nAgents: undefined, c: undefined };
          state.context = { wheelIf: null, askSet: null, ifelseCond: null };
          state.ticks = 0;
          meta.executed = true;
          break;
        }
        case 2: { // create-turtles N
          state.turtles = [];
          for (let who = 0; who < N; who++) {
            const p = initialPosForWho(who);
            state.turtles.push({ who, x: p.x, y: p.y });
            meta.activeTurtles.push(who);
          }
          meta.executed = true;
          break;
        }
        case 3: { // let nAgents count turtles
          state.vars.nAgents = state.turtles.length;
          meta.executed = true;
          break;
        }
        case 4: { // complete
          meta.executed = (G === 'complete');
          if (!meta.executed) break;
          const ids = turtleIds(state);
          meta.activeTurtles = ids.slice();
          // Equivalent effect: complete graph edges.
          for (let a = 0; a < ids.length; a++) {
            for (let b = a + 1; b < ids.length; b++) {
              const from = ids[a];
              const to = ids[b];
              const k = edgeKey(from, to);
              if (!state.links.includes(k)) {
                meta.newEdges.push(k);
                meta.newEdgeDisplay.push(`${from}-${to}`);
              }
              addLink(state, from, to);
            }
          }
          break;
        }
        case 5: { // cycle
          meta.executed = (G === 'cycle');
          if (!meta.executed) break;
          const ids = turtleIds(state);
          meta.activeTurtles = ids.slice();
          const nAgents = state.vars.nAgents ?? ids.length;
          for (const who of ids) {
            const to = ((who + 1) % nAgents);
            const k = edgeKey(who, to);
            if (!state.links.includes(k)) {
              meta.newEdges.push(k);
              meta.newEdgeDisplay.push(`${who}-${to}`);
            }
            addLink(state, who, to);
          }
          break;
        }
        case 6: { // if G = "wheel" [
          state.context.wheelIf = (G === 'wheel');
          state.context.askSet = null;
          meta.executed = true; // the "if" is evaluated; the block may be skipped.
          break;
        }
        case 7: { // let c turtle 0
          meta.executed = (state.context.wheelIf === true);
          if (!meta.executed) break;
          state.vars.c = 0;
          meta.activeTurtles = [0];
          break;
        }
        case 8: { // ask turtles with [who != 0] [
          meta.executed = (state.context.wheelIf === true);
          if (!meta.executed) break;
          state.context.askSet = turtleIds(state).filter(who => who !== 0);
          meta.activeTurtles = state.context.askSet.slice();
          break;
        }
        case 9: { // create-link-with c
          meta.executed = (state.context.wheelIf === true) && Array.isArray(state.context.askSet);
          if (!meta.executed) break;
          const c = state.vars.c;
          const askSet = state.context.askSet || [];
          meta.activeTurtles = askSet.slice();
          for (const who of askSet) {
            const k = edgeKey(who, c);
            if (!state.links.includes(k)) {
              meta.newEdges.push(k);
              meta.newEdgeDisplay.push(`${who}-${c}`);
            }
            addLink(state, who, c);
          }
          break;
        }
        case 10: { // create-link-with turtle (ifelse-value ...)
          meta.executed = (state.context.wheelIf === true) && Array.isArray(state.context.askSet);
          if (!meta.executed) break;
          const nAgents = state.vars.nAgents ?? state.turtles.length;
          const askSet = state.context.askSet || [];
          meta.activeTurtles = askSet.slice();
          for (const who of askSet) {
            const to = (who === nAgents - 1) ? 1 : (who + 1);
            const k = edgeKey(who, to);
            if (!state.links.includes(k)) {
              meta.newEdges.push(k);
              meta.newEdgeDisplay.push(`${who}-${to}`);
            }
            addLink(state, who, to);
          }
          break;
        }
        case 11: { // ] end ask
          meta.executed = (state.context.wheelIf === true);
          if (!meta.executed) break;
          state.context.askSet = null;
          break;
        }
        case 12: { // ] end wheel if
          // End of the wheel block scope.
          state.context.wheelIf = null;
          state.context.askSet = null;
          state.vars.c = undefined;
          meta.executed = true;
          break;
        }
        case 13: { // ifelse G = "wheel"
          state.context.ifelseCond = (G === 'wheel');
          meta.executed = true;
          break;
        }
        case 14: { // wheel layout branch
          meta.executed = (state.context.ifelseCond === true);
          if (!meta.executed) break;
          const ring = turtleIds(state).filter(who => who !== 0);
          const positions = layoutCircle(ring, 8);
          for (const who of ring) {
            const t = getTurtle(state, who);
            const p = positions.get(who);
            if (t && p) { t.x = p.x; t.y = p.y; }
          }
          const c = getTurtle(state, 0);
          if (c) { c.x = 0; c.y = 0; }
          meta.activeTurtles = [0, ...ring];
          break;
        }
        case 15: { // non-wheel layout branch
          meta.executed = (state.context.ifelseCond === false);
          if (!meta.executed) {
            // Still end the ifelse statement after showing skip on this line.
            state.context.ifelseCond = null;
            break;
          }
          const ids = turtleIds(state);
          const positions = layoutCircle(ids, 8);
          for (const who of ids) {
            const t = getTurtle(state, who);
            const p = positions.get(who);
            if (t && p) { t.x = p.x; t.y = p.y; }
          }
          meta.activeTurtles = ids.slice();
          // End the ifelse statement.
          state.context.ifelseCond = null;
          break;
        }
        case 16: { // reset-ticks
          state.ticks = 0;
          meta.executed = true;
          break;
        }
        case 17: { // end
          meta.executed = true;
          break;
        }
        default: {
          meta.executed = true;
        }
      }

      // Normalize.
      state.links = uniqSorted(state.links);
      state.turtles = state.turtles.slice().sort((a, b) => a.who - b.who);
      meta.activeTurtles = uniqSorted(meta.activeTurtles);
      meta.newEdges = uniqSorted(meta.newEdges);
      meta.newEdgeDisplay = uniqPreserveOrder(meta.newEdgeDisplay);
      return meta;
    }

    function diffStates(prev, next) {
      const prevIds = new Set(prev.turtles.map(t => t.who));
      const nextIds = new Set(next.turtles.map(t => t.who));
      const created = [];
      const removed = [];
      for (const who of nextIds) if (!prevIds.has(who)) created.push(who);
      for (const who of prevIds) if (!nextIds.has(who)) removed.push(who);

      const moved = [];
      for (const t of next.turtles) {
        const p = prev.turtles.find(x => x.who === t.who);
        if (!p) continue;
        if (Math.abs(p.x - t.x) > 1e-9 || Math.abs(p.y - t.y) > 1e-9) moved.push(t.who);
      }

      const prevLinks = new Set(prev.links);
      const nextLinks = new Set(next.links);
      const newLinks = [];
      const goneLinks = [];
      for (const k of nextLinks) if (!prevLinks.has(k)) newLinks.push(k);
      for (const k of prevLinks) if (!nextLinks.has(k)) goneLinks.push(k);

      const keys = new Set([...Object.keys(prev.vars), ...Object.keys(next.vars)]);
      const varsChanged = [];
      for (const k of keys) {
        if ((prev.vars[k] ?? null) !== (next.vars[k] ?? null)) varsChanged.push(k);
      }

      return {
        createdTurtles: created.sort((a, b) => a - b),
        removedTurtles: removed.sort((a, b) => a - b),
        movedTurtles: moved.sort((a, b) => a - b),
        createdLinks: newLinks.sort(),
        removedLinks: goneLinks.sort(),
        varsChanged: varsChanged.sort(),
        ticksChanged: (prev.ticks ?? null) !== (next.ticks ?? null),
      };
    }

    function makeExplainHtml(i, params, state, meta, delta) {
      const line = CODE_LINES[i];
      const G = params.G;
      const N = params.N;

      const execWord = meta.executed
        ? '<span style="color: var(--good); font-weight: 700">Executed</span>'
        : '<span style="color: var(--warn); font-weight: 700">Skipped</span>';

      const bullets = [];
      const add = (s) => bullets.push(`<p>• ${s}</p>`);

      switch (i) {
        case 0:
          add(`Enter the <code class="inline">setup</code> procedure. This line marks the start of the procedure and does not change the world state by itself.`);
          break;
        case 1:
          add(`<code class="inline">clear-all</code>: clears turtles/links (and other world state) and resets the tick counter.`);
          add(`In this teaching page, <code class="inline">N</code> and <code class="inline">G</code> are treated as UI inputs. So <code class="inline">clear-all</code> resets the world, but it does not “reset” your selected UI options.`);
          break;
        case 2:
          add(`<code class="inline">create-turtles N</code>: creates <code class="inline">${N}</code> turtles. In the demo we fix N=6, so you will see who=0,1,2,3,4,5.`);
          add(`On the right: newly created turtles are highlighted in green.`);
          break;
        case 3:
          add(`<code class="inline">let nAgents count turtles</code>: stores the current number of turtles into the local variable <code class="inline">nAgents</code>.`);
          add(`In the demo: <code class="inline">nAgents = 6</code>. Later lines use it for modulo arithmetic and for detecting the last turtle.`);
          break;
        case 4:
          add(`This is a conditional: only when <code class="inline">G = "complete"</code> do we create the edges of a complete graph. Current G=<code class="inline">${G}</code>, so this line is ${execWord}.`);
          if (meta.executed) {
            add(`<code class="inline">ask turtles [ create-links-with other turtles ]</code>: each turtle creates links to all other turtles, producing a complete graph (all pairs connected).`);
          } else {
            add(`Because the condition is false, no links are created on this line.`);
          }
          break;
        case 5:
          add(`When <code class="inline">G = "cycle"</code>, this line is ${execWord}. The goal is a ring: each turtle links to the “next” one (who+1), wrapping around with modulo.`);
          if (meta.executed) {
            add(`With N=6, this creates links (0-1),(1-2),(2-3),(3-4),(4-5),(5-0), forming a cycle.`);
          } else {
            add(`Because the condition is false, no links are created on this line.`);
          }
          break;
        case 6:
          add(`If <code class="inline">G = "wheel"</code>, the bracketed block that follows will run; otherwise the whole block is skipped. Current G=<code class="inline">${G}</code>.`);
          if (G === 'wheel') {
            add(`Wheel construction idea: pick a hub turtle (who=0), connect the hub to every other turtle, then connect the outer turtles into a ring.`);
            add(`<span class="muted">With N=6, wheel is not complete: it creates 5 hub links plus a 5-cycle among outer turtles (1–2–3–4–5–1), so some outer pairs (e.g., 1–3 and 2–4) are not directly connected.</span>`);
          }
          break;
        case 7:
          add(`Only in the wheel branch: <code class="inline">let c turtle 0</code> stores the hub turtle (who=0) in the local variable <code class="inline">c</code>. This line is ${execWord}.`);
          add(`In the diagram, turtle 0 will be annotated as <code class="inline">c</code> while this local variable is in scope (until the end of the wheel block).`);
          break;
        case 8:
          add(`Only in the wheel branch: <code class="inline">ask turtles with [who != 0]</code> selects all non-hub turtles (in the demo: who=1,2,3,4,5). This line is ${execWord}.`);
          add(`The commands inside the brackets run once per selected turtle (like “for each turtle in {1,2,3,4,5}”).`);
          break;
        case 9:
          add(`Inside the wheel <code class="inline">ask</code> block: each outer turtle runs <code class="inline">create-link-with c</code>, i.e., links to the hub turtle 0. This line is ${execWord}.`);
          break;
        case 10:
          add(`Also inside the wheel <code class="inline">ask</code> block: each outer turtle creates one “outer ring” edge.`);
          add(`<code class="inline">ifelse-value (who = nAgents - 1) [ 1 ] [ who + 1 ]</code> means: if the current turtle is the last one (who=5), link back to turtle 1; otherwise link to the next turtle.`);
          add(`With N=6, the outer ring creates (1-2),(2-3),(3-4),(4-5),(5-1). This line is ${execWord}.`);
          break;
        case 11:
          add(`End of the wheel <code class="inline">ask ... [ ... ]</code> block. The right-side “active agents” highlight leaves the ask set here. This line is ${execWord}.`);
          break;
        case 12:
          add(`End of the wheel <code class="inline">if ... [ ... ]</code> block. The local variable <code class="inline">c</code> goes out of scope here. This line is ${execWord}.`);
          add(`After this line, the <code class="inline">c</code> annotation disappears because the variable is no longer defined (even though turtle 0 still exists).`);
          break;
        case 13:
          add(`<code class="inline">ifelse G = "wheel"</code>: chooses the layout strategy based on G. The condition is evaluated once, and only one branch runs. Current G=<code class="inline">${G}</code>.`);
          add(`The next two lines are the two branches (one will execute, the other will be skipped).`);
          break;
        case 14:
          add(`Wheel branch layout: <code class="inline">layout-circle sort turtles with [who != 0] 8</code> places the outer turtles on a circle of radius 8; then <code class="inline">ask turtle 0 [ setxy 0 0 ]</code> places the hub at the origin.`);
          add(`<strong>Why <code class="inline">sort</code> matters:</strong> <code class="inline">turtles with [...]</code> is an <em>agentset</em> (unordered). If you pass an agentset directly to <code class="inline">layout-circle</code>, NetLogo iterates it in a random order, so the placement around the circle can be different each run. Using <code class="inline">sort</code> converts the agentset into a stable list ordered by <code class="inline">who</code>, which makes the drawing look like a clean ring instead of a scrambled polygon.`);
          add(`Current G=<code class="inline">${G}</code>, so this line is ${execWord}.`);
          break;
        case 15:
          add(`Non-wheel branch layout: <code class="inline">layout-circle sort turtles 8</code> places all turtles on a circle of radius 8 (in <code class="inline">who</code> order).`);
          add(`If you remove <code class="inline">sort</code> here, the circle order is random, so a cycle graph (edges by who+1) will often <em>look</em> messy because many edges will cross.`);
          add(`Current G=<code class="inline">${G}</code>, so this line is ${execWord}.`);
          break;
        case 16:
          add(`<code class="inline">reset-ticks</code>: resets the tick counter to 0. It is commonly placed at the end of <code class="inline">setup</code> so the simulation starts counting from 0.`);
          break;
        case 17:
          add(`End of the procedure (<code class="inline">end</code>). This line does not change the world state.`);
          break;
        default:
          add(`(No explanation defined.)`);
      }

      // Add a compact "what changed" summary (derived from diff).
      const changes = [];
      if (delta.createdTurtles.length) changes.push(`Added turtles: ${delta.createdTurtles.map(x => `who=${x}`).join(', ')}`);
      if (delta.removedTurtles.length) changes.push(`Removed turtles: ${delta.removedTurtles.map(x => `who=${x}`).join(', ')}`);
      if (delta.createdLinks.length) {
        // Display link creation in the same orientation/order as the code path, when available.
        const display = (meta.newEdgeDisplay && meta.newEdgeDisplay.length) ? meta.newEdgeDisplay : delta.createdLinks;
        changes.push(`Added links: ${display.join(', ')}`);
      }
      if (delta.removedLinks.length) changes.push(`Removed links: ${delta.removedLinks.join(', ')}`);
      if (delta.movedTurtles.length) changes.push(`Moved turtles: ${delta.movedTurtles.map(x => `who=${x}`).join(', ')}`);

      if (changes.length) {
        add(`<span class="muted"><strong>Concrete visible change in the demo:</strong> ${changes.join('; ')}</span>`);
      } else {
        add(`<span class="muted"><strong>Concrete visible change in the demo:</strong> (none)</span>`);
      }

      return bullets.join('');
    }

    // DOM references
    const codeBody = document.getElementById('codeBody');
    const stepTitle = document.getElementById('stepTitle');
    const stepBadge = document.getElementById('stepBadge');
    const explain = document.getElementById('explain');
    const gSelect = document.getElementById('gSelect');
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnReset = document.getElementById('btnReset');
    const gridLayer = document.getElementById('gridLayer');
    const edgeLayer = document.getElementById('edgeLayer');
    const turtleLayer = document.getElementById('turtleLayer');

    // World rendering caches for stable DOM nodes (so transitions work).
    const turtleEls = new Map(); // who -> g
    const edgeEls = new Map();   // key -> line

    let currentLine = 0;
    let timeline = null; // { states: [], metas: [], deltas: [] }

    function buildCodeView() {
      codeBody.innerHTML = '';
      CODE_LINES.forEach((src, idx) => {
        const el = document.createElement('div');
        el.className = 'line';
        el.dataset.idx = String(idx);
        el.innerHTML = `<div class="ln">${idx + 1}</div><div class="src">${escapeHtml(src)}</div>`;
        el.addEventListener('click', () => gotoLine(idx));
        codeBody.appendChild(el);
      });
    }

    function escapeHtml(s) {
      return s
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function computeTimeline(params) {
      const states = [];
      const metas = [];
      const deltas = [];
      let sPrev = makeState(params);

      for (let i = 0; i < CODE_LINES.length; i++) {
        const sNext = cloneState(sPrev);
        const meta = applyLine(i, sNext, params);
        const delta = diffStates(sPrev, sNext);
        states.push(sNext);
        metas.push(meta);
        deltas.push(delta);
        sPrev = sNext;
      }
      return { states, metas, deltas };
    }

    function renderGrid() {
      gridLayer.innerHTML = '';
      // Light grid lines every 2 units.
      for (let x = -10; x <= 10; x += 2) {
        const ln = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        ln.setAttribute('x1', String(x));
        ln.setAttribute('y1', String(-10));
        ln.setAttribute('x2', String(x));
        ln.setAttribute('y2', String(10));
        ln.setAttribute('class', 'gridline');
        gridLayer.appendChild(ln);
      }
      for (let y = -10; y <= 10; y += 2) {
        const ln = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        ln.setAttribute('x1', String(-10));
        ln.setAttribute('y1', String(y));
        ln.setAttribute('x2', String(10));
        ln.setAttribute('y2', String(y));
        ln.setAttribute('class', 'gridline');
        gridLayer.appendChild(ln);
      }
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      xAxis.setAttribute('x1', '-10');
      xAxis.setAttribute('y1', '0');
      xAxis.setAttribute('x2', '10');
      xAxis.setAttribute('y2', '0');
      xAxis.setAttribute('class', 'axis');
      gridLayer.appendChild(xAxis);
      const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      yAxis.setAttribute('x1', '0');
      yAxis.setAttribute('y1', '-10');
      yAxis.setAttribute('x2', '0');
      yAxis.setAttribute('y2', '10');
      yAxis.setAttribute('class', 'axis');
      gridLayer.appendChild(yAxis);
    }

    function renderWorld(state, meta, delta) {
      // Edges: keep stable elements.
      const wantedEdges = new Set(state.links);
      for (const [k, el] of edgeEls.entries()) {
        if (!wantedEdges.has(k)) {
          el.remove();
          edgeEls.delete(k);
        }
      }
      for (const k of state.links) {
        let el = edgeEls.get(k);
        const [aStr, bStr] = k.split('-');
        const a = Number(aStr);
        const b = Number(bStr);
        const ta = getTurtle(state, a);
        const tb = getTurtle(state, b);
        if (!ta || !tb) continue;
        if (!el) {
          el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          el.setAttribute('class', 'edge');
          edgeEls.set(k, el);
          edgeLayer.appendChild(el);
        }
        const isNew = meta.newEdges.includes(k) || delta.createdLinks.includes(k);
        // Match the CSS sizes (viewBox units) so edges end outside the node outline.
        const nodeR = 0.90;
        const nodeStroke = 0.18;
        const edgeStroke = isNew ? 0.30 : 0.22;
        const pad = (nodeR + nodeStroke / 2) + (edgeStroke / 2);
        const seg = clippedSegment({ x: ta.x, y: ta.y }, { x: tb.x, y: tb.y }, pad, pad);
        el.setAttribute('x1', String(seg.x1));
        el.setAttribute('y1', String(seg.y1));
        el.setAttribute('x2', String(seg.x2));
        el.setAttribute('y2', String(seg.y2));

        el.classList.remove('new', 'active');
        if (meta.newEdges.includes(k) || delta.createdLinks.includes(k)) el.classList.add('new');
      }

      // Turtles: keep stable elements.
      const wantedTurtles = new Set(state.turtles.map(t => t.who));
      for (const [who, el] of turtleEls.entries()) {
        if (!wantedTurtles.has(who)) {
          el.remove();
          turtleEls.delete(who);
        }
      }

      for (const t of state.turtles) {
        let g = turtleEls.get(t.who);
        if (!g) {
          g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('class', 'turtle');
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          txt.textContent = String(t.who);
          const alias = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          alias.setAttribute('class', 'alias');
          alias.setAttribute('y', '-1.15');
          g.appendChild(c);
          g.appendChild(txt);
          g.appendChild(alias);
          turtleEls.set(t.who, g);
          turtleLayer.appendChild(g);
        }

        g.setAttribute('transform', `translate(${t.x} ${t.y})`);
        g.classList.remove('active', 'created', 'center');
        if (PARAMS.G === 'wheel' && t.who === 0) g.classList.add('center');
        if (meta.activeTurtles.includes(t.who)) g.classList.add('active');
        if (delta.createdTurtles.includes(t.who)) g.classList.add('created');

        // Annotate c only while the local variable is in scope.
        const aliasEl = g.querySelector('text.alias');
        if (aliasEl) {
          const showC = (PARAMS.G === 'wheel') && (state.vars.c === t.who);
          aliasEl.textContent = showC ? 'c' : '';
          aliasEl.style.display = showC ? 'block' : 'none';
        }
      }
    }


    function updateCodeHighlight(i) {
      const lines = codeBody.querySelectorAll('.line');
      lines.forEach(el => {
        const idx = Number(el.dataset.idx);
        el.classList.toggle('current', idx === i);
        el.classList.toggle('executed', timeline.metas[idx].executed);
        el.classList.toggle('skipped', !timeline.metas[idx].executed);
      });

      // Keep the current line in view by scrolling the code panel only.
      const cur = codeBody.querySelector(`.line[data-idx="${i}"]`);
      if (cur) {
        const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const targetTop = cur.offsetTop - (codeBody.clientHeight / 2) + (cur.clientHeight / 2);
        codeBody.scrollTo({ top: Math.max(0, targetTop), behavior: reduce ? 'auto' : 'smooth' });
      }
    }

    function render(i) {
      const state = timeline.states[i];
      const meta = timeline.metas[i];
      const delta = timeline.deltas[i];

      updateCodeHighlight(i);

      const src = CODE_LINES[i];
      stepTitle.textContent = `#${i + 1}  ${src.trim()}`;
      const exec = meta.executed
        ? `<span class="ok">Executed</span>`
        : `<span class="skip">Skipped</span>`;
      stepBadge.innerHTML = `Line <strong>${i + 1}</strong> / ${CODE_LINES.length} · G=<strong>${escapeHtml(PARAMS.G)}</strong> · This line: ${exec}`;

      explain.innerHTML = makeExplainHtml(i, PARAMS, state, meta, delta);
      renderWorld(state, meta, delta);

      btnPrev.disabled = (i <= 0);
      btnNext.disabled = (i >= CODE_LINES.length - 1);
    }

    function gotoLine(i) {
      currentLine = Math.max(0, Math.min(CODE_LINES.length - 1, i));
      render(currentLine);
    }

    function rebuild() {
      timeline = computeTimeline(PARAMS);
      renderGrid();
      gotoLine(currentLine);
    }

    // Controls
    gSelect.addEventListener('change', () => {
      PARAMS.G = gSelect.value;
      rebuild();
    });
    btnPrev.addEventListener('click', () => gotoLine(currentLine - 1));
    btnNext.addEventListener('click', () => gotoLine(currentLine + 1));
    btnReset.addEventListener('click', () => gotoLine(0));

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') gotoLine(currentLine + 1);
      if (e.key === 'ArrowLeft') gotoLine(currentLine - 1);
      if (e.key === 'Home') gotoLine(0);
      if (e.key === 'End') gotoLine(CODE_LINES.length - 1);
    });

    // Init
    buildCodeView();
    gSelect.value = PARAMS.G;
    rebuild();
  </script>
</body>
</html>
